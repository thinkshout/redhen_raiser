<?php
/**
 * @file
 * Unit tests for the commerce recurring module.
 */

class CommerceRecurringTestCase extends CommerceBaseTestCase {
  /**
   * @var stdClass
   * User for the testing.
   */
  private $customer = NULL;

  /**
   * getInfo() returns properties that are displayed in the test selection form.
   */
  public static function getInfo() {
    return array(
      'name' => t('Commerce recurring'),
      'description' => t('Commerce recurring tests.'),
      'group' => t('Commerce recurring'),
    );
  }

  /**
   * setUp() performs any pre-requisite tasks that need to happen.
   */
  public function setUp() {
    $other_modules = array(
      'interval',
      'entityreference',
      'date',
      'date_popup',
      'commerce_recurring',
    );
    $modules = parent::setUpHelper('all', $other_modules);
    parent::setUp($modules);

    $this->customer = $this->createStoreCustomer();
    cache_clear_all(); // Just in case
  }

  /**
   * Creates a recurring product for use with other tests.
   * @return
   *  A product with most of it's basic fields set random values.
   *  FALSE if the appropiate modules were not available.
   */
  public function createRecurringProduct() {
    $new_product = commerce_product_new('recurring');
    $new_product->sku = $this->randomName(10);
    $new_product->title = $this->randomName(10);
    $new_product->uid = 1;
    $period = array();

    // Set prices.
    $new_product->commerce_price[LANGUAGE_NONE][0]['amount'] = rand(200, 50000);
    $new_product->commerce_price[LANGUAGE_NONE][0]['currency_code'] = 'USD';
    $new_product->commerce_recurring_ini_price[LANGUAGE_NONE][0]['amount'] = rand(200, 50000);
    $new_product->commerce_recurring_ini_price[LANGUAGE_NONE][0]['currency_code'] = 'USD';
    $new_product->commerce_recurring_rec_price[LANGUAGE_NONE][0]['amount'] = rand(200, 50000);
    $new_product->commerce_recurring_rec_price[LANGUAGE_NONE][0]['currency_code'] = 'USD';

    // Set intervals.
    foreach (array('commerce_recurring_ini_period', 'commerce_recurring_rec_period', 'commerce_recurring_end_period') as $field_name) {
      $instance = field_info_instance('commerce_product', $field_name, 'recurring');
      $period[] = array_rand($instance['settings']['allowed_periods'], 1);
    }
    $new_product->commerce_recurring_ini_period[LANGUAGE_NONE][0]['interval'] = rand(2,25);
    $new_product->commerce_recurring_ini_period[LANGUAGE_NONE][0]['period'] = $period[0];
    $new_product->commerce_recurring_rec_period[LANGUAGE_NONE][0]['interval'] = rand(2,25);
    $new_product->commerce_recurring_rec_period[LANGUAGE_NONE][0]['period'] = $period[0];
    $new_product->commerce_recurring_end_period[LANGUAGE_NONE][0]['interval'] = rand(2,25);
    $new_product->commerce_recurring_end_period[LANGUAGE_NONE][0]['period'] = $period[0];

    commerce_product_save($new_product);

    return $new_product;
  }

  /**
   * Creates a recurring entity to be used in other tests.
   * @param entity $product
   *   Commerce Product assigned to the Recurring entity.
   * @param int $quantity
   *   Quantity of the product.
   * @param int $start_date
   *   Initial date for recurring.
   * @param int $due_date
   *   Due date for recurring.
   * @param int $end_date
   *   End date for recurring.
   *
   * @return bool A recurring entity with fields configured randomly unless they're
   */
  public function createRecurringEntity($product = NULL, $quantity = 1, $start_date = NULL, $due_date = NULL, $end_date = NULL) {
    if (empty($product)) {
      $product = $this->createRecurringProduct();
    }
    $line_item = commerce_cart_product_add_by_id($product->product_id, 1, TRUE, $this->customer->uid);

    if (empty($start_date)) {
      $start_date = new DateObject('2010-01-01');
    }

    if (empty($due_date)) {
      $due_date = new DateObject();
      $due_date->sub(new DateInterval('P1D'));
    }

    // Create the recurring entity faking the dates to be due.
    $values = array(
      'type' => 'product',
      'product_id' => $product->product_id,
      'order_ids' => array($line_item->order_id),
      'start_date' => $start_date->getTimestamp(),
      'due_date' => $due_date->getTimestamp(),
      'end_date' => !empty($end_date) ? $end_date->getTimestamp() : NULL,
      'uid' => $this->customer->uid,
      'quantity' => isset($quantity) ? $quantity : 1,
    );
    $recurring_entity = commerce_recurring_new($values);
    entity_save('commerce_recurring', $recurring_entity);

    return $recurring_entity;
  }

  /**
   * Test creating a recurring product.
   */
  function testCreateRecurringProduct() {
    $store_admin = $this->createStoreAdmin();
    $this->drupalLogin($store_admin);
    $this->drupalGet('admin/commerce/products/add/recurring');

    foreach (array('commerce_recurring_ini_period', 'commerce_recurring_rec_period', 'commerce_recurring_end_period') as $field_name) {
      $instance = field_info_instance('commerce_product', $field_name, 'recurring');
      $period[] = array_rand($instance['settings']['allowed_periods'], 1);
    }

    // Create the recurring product.
    $edit = array(
      'sku' => 'PROD-01',
      'title' => $this->randomName(10),
      'commerce_price[und][0][amount]' => commerce_currency_amount_to_decimal(rand(200,50000), 'USD'),
      'commerce_recurring_ini_price[und][0][amount]' => commerce_currency_amount_to_decimal(rand(200,50000), 'USD'),
      'commerce_recurring_rec_price[und][0][amount]' => commerce_currency_amount_to_decimal(rand(200,50000), 'USD'),
      'commerce_recurring_ini_period[und][0][interval]' => rand(2,10),
      'commerce_recurring_ini_period[und][0][period]' => $period[0],
      'commerce_recurring_rec_period[und][0][interval]' => rand(2,10),
      'commerce_recurring_rec_period[und][0][period]' => $period[1],
      'commerce_recurring_end_period[und][0][interval]' => rand(2,10),
      'commerce_recurring_end_period[und][0][period]' => $period[2],
      'status' => 1,
    );
    $this->drupalPost(NULL, $edit, t('Save product'));
    $this->assertText(t('Product saved.'), t('%message message is present', array('%message' => t('Product saved'))));
    $this->assertText(t('Recurring product'), t('Recurring product type name found after creating a product of that type'));

    // Check the product in database.
    $product = commerce_product_load_by_sku($edit['sku']);
    $product_wrapper = entity_metadata_wrapper('commerce_product', $product);
    $this->pass(t('Test the product edit in database:'));
    $this->assertTrue($product_wrapper->sku->value()  == $edit['sku'], t('SKU stored in database correctly set'));
    $this->assertTrue($product_wrapper->title->value()  == $edit['title'], t('Title stored in database correctly set'));
    $this->assertTrue(commerce_currency_amount_to_decimal($product_wrapper->commerce_price->amount->value(), $product_wrapper->commerce_price->currency_code->value()) == $edit['commerce_price[und][0][amount]'], t('Amount stored in database correctly set'));
    $this->assertTrue($product->status  == $edit['status'], t('Status stored in database correctly set'));
    $this->assertTrue(commerce_currency_amount_to_decimal($product_wrapper->commerce_recurring_ini_price->amount->value(), $product_wrapper->commerce_recurring_ini_price->currency_code->value()) == $edit['commerce_recurring_ini_price[und][0][amount]'], t('Initial amount stored in database correctly set'));
    $this->assertTrue(commerce_currency_amount_to_decimal($product_wrapper->commerce_recurring_rec_price->amount->value(), $product_wrapper->commerce_recurring_rec_price->currency_code->value()) == $edit['commerce_recurring_rec_price[und][0][amount]'], t('Recurring amount stored in database correctly set'));
    $this->assertTrue($product_wrapper->commerce_recurring_ini_period->interval->value() == $edit['commerce_recurring_ini_period[und][0][interval]'], t('Initial period stored in database correctly set'));
    $this->assertTrue($product_wrapper->commerce_recurring_ini_period->period->value() == $edit['commerce_recurring_ini_period[und][0][period]'], t('Initial interval stored in database correctly set'));
    $this->assertTrue($product_wrapper->commerce_recurring_rec_period->interval->value() == $edit['commerce_recurring_rec_period[und][0][interval]'], t('Initial period stored in database correctly set'));
    $this->assertTrue($product_wrapper->commerce_recurring_rec_period->period->value() == $edit['commerce_recurring_rec_period[und][0][period]'], t('Initial interval stored in database correctly set'));
    $this->assertTrue($product_wrapper->commerce_recurring_end_period->interval->value() == $edit['commerce_recurring_end_period[und][0][interval]'], t('Initial period stored in database correctly set'));
    $this->assertTrue($product_wrapper->commerce_recurring_end_period->period->value() == $edit['commerce_recurring_end_period[und][0][period]'], t('Initial interval stored in database correctly set'));
  }

  /**
   * Create a Recurring entity.
   */
  function testCommerceRecurringEntityCreation() {
    $product = $this->createRecurringProduct();
    $line_item = commerce_cart_product_add_by_id($product->product_id);
    $order = commerce_order_load($line_item->order_id);
    $recurring_entity = commerce_recurring_new_from_product($order, $product, $line_item->commerce_unit_price[LANGUAGE_NONE][0], $line_item->quantity);
    entity_save('commerce_recurring', $recurring_entity);
    $recurring_entity_load = entity_load_single('commerce_recurring', $recurring_entity->id);
    $this->assertTrue($recurring_entity->id == 1, t('Recurring entity has generated an id.'));
    $this->assertEqual($recurring_entity_load->commerce_recurring_ref_product[LANGUAGE_NONE][0]['target_id'], $recurring_entity->commerce_recurring_ref_product[LANGUAGE_NONE][0]['target_id'], t('Product values correctly set for the recurring entity saved.'));
    $this->assertEqual($recurring_entity_load->commerce_recurring_order[LANGUAGE_NONE][0]['target_id'], $recurring_entity->commerce_recurring_order[LANGUAGE_NONE][0]['target_id'], t('Order values correctly set for the recurring entity saved.'));
  }

  /**
   * When creating an order and finish a payment, recurring entity
   */
  function testCommerceRecurringEntityCreationWorkflow() {
    // Login as a customer to proceed with the order.
    $this->drupalLogin($this->customer);

    // Add a product to the cart and go on in checkout.
    $product = $this->createRecurringProduct();
    $product_wrapper = entity_metadata_wrapper('commerce_product', $product);
    $line_item = commerce_cart_product_add_by_id($product->product_id, 1, TRUE, $this->customer->uid);
    $this->drupalPost($this->getCommerceUrl('cart'), array(), t('Checkout'));

    // Generate random information, as city, postal code, etc.
    $address_info = $this->generateAddressInformation();
    // Fill in the billing address information.
    $billing_pane = $this->xpath("//select[starts-with(@name, 'customer_profile_billing[commerce_customer_address]')]");
    $this->drupalPostAJAX(NULL, array((string) $billing_pane[0]['name'] => 'US'), (string) $billing_pane[0]['name']);
    // Fill in the required information for billing pane, with a random State.
    $info = array(
      'customer_profile_billing[commerce_customer_address][und][0][name_line]' => $address_info['name_line'],
      'customer_profile_billing[commerce_customer_address][und][0][thoroughfare]' => $address_info['thoroughfare'],
      'customer_profile_billing[commerce_customer_address][und][0][locality]' => $address_info['locality'],
      'customer_profile_billing[commerce_customer_address][und][0][administrative_area]' => 'KY',
      'customer_profile_billing[commerce_customer_address][und][0][postal_code]' => $address_info['postal_code'],
    );
    $this->drupalPost(NULL, $info, t('Continue to next step'));
    // Finish checkout process
    $this->drupalPost(NULL, array('commerce_payment[payment_method]' => 'commerce_payment_example|commerce_payment_commerce_payment_example'), t('Continue to next step'));

    // Load recurring entities.
    $order = commerce_order_load($line_item->order_id);
    $recurring_entities = commerce_recurring_load_by_order($order);
    $recurring_entity = reset($recurring_entities);
    $recurring_wrapper = entity_metadata_wrapper('commerce_recurring', $recurring_entity);

    // Gather expected dates.
    $start_date = $recurring_wrapper->start_date->value();
    $due_date = new DateObject($start_date);
    $end_date = new DateObject($start_date);
    $initial_interval = $product_wrapper->commerce_recurring_ini_period->value();
    $end_interval = $product_wrapper->commerce_recurring_end_period->value();
    interval_apply_interval($due_date, $initial_interval, TRUE);
    interval_apply_interval($end_date, $end_interval, TRUE);

    // Assert if the recurring entity is being created as expected.
    $this->assertEqual($recurring_wrapper->commerce_recurring_ref_product->value(), $product, t('Product is correctly set in the recurring entity'));
    $this->assertEqual($recurring_wrapper->commerce_recurring_order->get(0)->order_id->value(), $order->order_id, t('Order is correctly set in the recurring entity'));
    $this->assertEqual($recurring_wrapper->commerce_recurring_fixed_price->amount->value(), $product_wrapper->commerce_recurring_ini_price->amount->value(), t('Initial price is correctly set for the recurring entity'));
    $this->assertEqual($recurring_wrapper->due_date->value(), $due_date->getTimestamp(), t('Recurring date is set for the recurring entity'));
    $this->assertEqual($recurring_wrapper->end_date->value(), $end_date->getTimestamp(), t('End date is set for the recurring entity'));
  }

  /**
   * Test workflow with no initial date.
   */
  function testCommerceRecurringEntityCreationWorkflowNoInitialDate() {
    // Login as a customer to proceed with the order.
    $this->drupalLogin($this->customer);

    // Add a product to the cart without initial period.
    $product = commerce_product_new('recurring');
    $product->sku = $this->randomName(10);
    $product->title = $this->randomName(10);
    $product->uid = 1;
    $period = array();

    // Set prices.
    $product->commerce_price[LANGUAGE_NONE][0]['amount'] = rand(200, 50000);
    $product->commerce_price[LANGUAGE_NONE][0]['currency_code'] = 'USD';
    $product->commerce_recurring_ini_price[LANGUAGE_NONE][0]['amount'] = rand(200, 50000);
    $product->commerce_recurring_ini_price[LANGUAGE_NONE][0]['currency_code'] = 'USD';
    $product->commerce_recurring_rec_price[LANGUAGE_NONE][0]['amount'] = rand(200, 50000);
    $product->commerce_recurring_rec_price[LANGUAGE_NONE][0]['currency_code'] = 'USD';

    // Set intervals.
    foreach (array('commerce_recurring_ini_period', 'commerce_recurring_rec_period', 'commerce_recurring_end_period') as $field_name) {
      $instance = field_info_instance('commerce_product', $field_name, 'recurring');
      $period[] = array_rand($instance['settings']['allowed_periods'], 1);
    }
    $product->commerce_recurring_rec_period[LANGUAGE_NONE][0]['interval'] = rand(2,25);
    $product->commerce_recurring_rec_period[LANGUAGE_NONE][0]['period'] = $period[0];
    $product->commerce_recurring_end_period[LANGUAGE_NONE][0]['interval'] = rand(2,25);
    $product->commerce_recurring_end_period[LANGUAGE_NONE][0]['period'] = $period[0];
    commerce_product_save($product);

    $product_wrapper = entity_metadata_wrapper('commerce_product', $product);
    $line_item = commerce_cart_product_add_by_id($product->product_id, 1, TRUE, $this->customer->uid);
    $this->drupalPost($this->getCommerceUrl('cart'), array(), t('Checkout'));

    // Generate random information, as city, postal code, etc.
    $address_info = $this->generateAddressInformation();
    // Fill in the billing address information.
    $billing_pane = $this->xpath("//select[starts-with(@name, 'customer_profile_billing[commerce_customer_address]')]");
    $this->drupalPostAJAX(NULL, array((string) $billing_pane[0]['name'] => 'US'), (string) $billing_pane[0]['name']);
    // Fill in the required information for billing pane, with a random State.
    $info = array(
      'customer_profile_billing[commerce_customer_address][und][0][name_line]' => $address_info['name_line'],
      'customer_profile_billing[commerce_customer_address][und][0][thoroughfare]' => $address_info['thoroughfare'],
      'customer_profile_billing[commerce_customer_address][und][0][locality]' => $address_info['locality'],
      'customer_profile_billing[commerce_customer_address][und][0][administrative_area]' => 'KY',
      'customer_profile_billing[commerce_customer_address][und][0][postal_code]' => $address_info['postal_code'],
    );
    $this->drupalPost(NULL, $info, t('Continue to next step'));
    // Finish checkout process
    $this->drupalPost(NULL, array('commerce_payment[payment_method]' => 'commerce_payment_example|commerce_payment_commerce_payment_example'), t('Continue to next step'));

    // Load recurring entities.
    $order = commerce_order_load($line_item->order_id);
    $recurring_entities = commerce_recurring_load_by_order($order);
    $recurring_entity = reset($recurring_entities);
    $recurring_wrapper = entity_metadata_wrapper('commerce_recurring', $recurring_entity);

    // Gather expected dates.
    $start_date = $recurring_wrapper->start_date->value();
    $due_date = new DateObject($start_date);
    $end_date = new DateObject($start_date);
    $initial_interval = $product_wrapper->commerce_recurring_rec_period->value();
    $end_interval = $product_wrapper->commerce_recurring_end_period->value();
    interval_apply_interval($due_date, $initial_interval, TRUE);
    interval_apply_interval($end_date, $end_interval, TRUE);

    // Assert if the recurring entity is being created as expected.
    $this->assertEqual($recurring_wrapper->commerce_recurring_ref_product->value(), $product, t('Product is correctly set in the recurring entity'));
    $this->assertEqual($recurring_wrapper->commerce_recurring_order->get(0)->order_id->value(), $order->order_id, t('Order is correctly set in the recurring entity'));
    $this->assertEqual($recurring_wrapper->commerce_recurring_fixed_price->amount->value(), $product_wrapper->commerce_recurring_ini_price->amount->value(), t('Initial price is correctly set for the recurring entity'));
    $this->assertEqual($recurring_wrapper->due_date->value(), $due_date->getTimestamp(), t('Recurring date is set for the recurring entity'));
    $this->assertEqual($recurring_wrapper->end_date->value(), $end_date->getTimestamp(), t('End date is set for the recurring entity'));
  }

  /**
   * Test cron run and order creation on recurring entity date base.
   */
  function testCommerceRecurringCronOrderCreation() {
    // Create a recurring entity.
    $product = $this->createRecurringProduct();
    $product_wrapper = entity_metadata_wrapper('commerce_product', $product);
    $line_item = commerce_cart_product_add_by_id($product->product_id, 1, TRUE, $this->customer->uid);
    $recurring_entity = $this->createRecurringEntity($product);

    $initial_order = commerce_order_load($line_item->order_id);
    $initial_order->commerce_customer_billing = (array) $this->createDummyCustomerProfile('billing', $this->customer->uid);
    $initial_order->status = 'completed';
    commerce_order_save($initial_order);
    commerce_cart_order_ids_reset();

    // Run cron.
    drupal_cron_run();
    // Check if the order has been correctly created and it's linked to the
    // recurring entity.
    $recurring_entities = entity_load('commerce_recurring', array($recurring_entity->id), array(), TRUE);
    $recurring_entity = reset($recurring_entities);
    $recurring_wrapper = entity_metadata_wrapper('commerce_recurring', $recurring_entity);

    // The order is the second one now.
    $order_wrapper = $recurring_wrapper->commerce_recurring_order->get(1);
    $order = $order_wrapper->value();

    $this->assertTrue(isset($order), t('New order has been created for the recurring entity'));
    $this->assertEqual($order->data['recurring_entity'], $recurring_entity->id, t('Recurring id is associated with the order'));
    $this->assertEqual($order_wrapper->commerce_order_total->amount->value(), $product_wrapper->commerce_recurring_rec_price->amount->value(), t('Total price is calculated ok'));
    $this->assertEqual($order->status, 'recurring_pending', t('Order is created in recurring_pending status'));

    $first_order = $recurring_wrapper->commerce_recurring_order->get(0)->value();
    $this->assertEqual($order->commerce_customer_billing, $first_order->commerce_customer_billing, t('Customer profile information gets copied from the initial order to the recurring one'));

    $user_current_cart = commerce_cart_order_load($this->customer->uid);
    $this->assertTrue(empty($user_current_cart), t('Customer cart is empty after creating a recurring order'));
  }

  /**
   * Test recurring entity update when orders created in cron are processed.
   */
  function testCommerceRecurringUpdateRecurringEntity() {
    // Create a recurring entity.
    $product = $this->createRecurringProduct();
    $line_item = commerce_cart_product_add_by_id($product->product_id, 1, TRUE, $this->customer->uid);
    $start_date = new DateObject('2010-01-01');
    $due_date = new DateObject();
    $due_date->sub(new DateInterval('P1D'));
    $recurring_entity = $this->createRecurringEntity($product, 1, $start_date, $due_date);

    $initial_order = commerce_order_load($line_item->order_id);
    $initial_order->commerce_customer_billing = (array) $this->createDummyCustomerProfile('billing', $this->customer->uid);
    $initial_order->status = 'completed';
    commerce_order_save($initial_order);

    // Run cron.
    drupal_cron_run();
    // Check if the order has been correctly created and it's linked to the
    // recurring entity.
    $recurring_entities = entity_load('commerce_recurring', array($recurring_entity->id), array(), TRUE);
    $recurring_entity = reset($recurring_entities);
    $recurring_wrapper = entity_metadata_wrapper('commerce_recurring', $recurring_entity);
    // The order is the second one now.
    $order = $recurring_wrapper->commerce_recurring_order->get(1)->value();

    // Mock a payment that triggers Paid in full event.
    $payment_method = array('instance_id' => 'commerce_payment_example');
    $charge = array(
      'amount' => $order->commerce_order_total[LANGUAGE_NONE][0]['amount'],
      'currency_code' => $order->commerce_order_total[LANGUAGE_NONE][0]['currency_code'],
    );

    // Accomodate the default payment example order data values.
    $number = '4111111111111111';
    $order->data['commerce_payment_example'] = array(
      'credit_card' => array(
        'number' => substr($number, 0, 4) . str_repeat('-', strlen($number) - 8) . substr($number, -4),
        'exp_month' => date('m'),
        'exp_year' => date('Y'),
      ),
    );

    commerce_payment_example_transaction($payment_method, $order, $charge, 'Test payment');

    $recurring_entities = entity_load('commerce_recurring', array($order->data['recurring_entity']), array(), TRUE);
    $reloaded_recurring_entity = reset($recurring_entities);
    $reloaded_recurring_entity_wrapper = entity_metadata_wrapper('commerce_recurring', $reloaded_recurring_entity);

    // Check if the recurring entity has been updated correctly.
    $this->assertTrue(in_array($order->order_id, $reloaded_recurring_entity_wrapper->commerce_recurring_order->raw()), t('Order is associated with the recurring entity.'));
    $count_values = array_count_values($reloaded_recurring_entity_wrapper->commerce_recurring_order->raw());
    $this->assertEqual($count_values[$order->order_id], 1, t('Order is associated once with the recurring entity.'));

    // Due date needs to be updated to the next recurring period.
    $product_wrapper = $reloaded_recurring_entity_wrapper->commerce_recurring_ref_product;
    $recurring_interval = $product_wrapper->commerce_recurring_rec_period->value();
    interval_apply_interval($due_date, $recurring_interval, TRUE);
    $this->assertEqual($due_date->getTimestamp(), $reloaded_recurring_entity_wrapper->due_date->value(), t('Recurring due date is correct.'));
  }

  /**
   * Test recurring entity end date.
   */
  function testCommerceRecurringEndDate() {
    // Create a recurring entity.
    $product = $this->createRecurringProduct();
    $line_item = commerce_cart_product_add_by_id($product->product_id, 1, TRUE, $this->customer->uid);
    $start_date = new DateObject('2010-01-01');
    $due_date = new DateObject();
    $due_date->sub(new DateInterval('P1D'));
    // Set the end date to be 1H before now.
    $end_date = new DateObject();
    $end_date->sub(new DateInterval('PT1H'));
    $recurring_entity = $this->createRecurringEntity($product, 1, $start_date, $due_date, $end_date);

    $initial_order = commerce_order_load($line_item->order_id);
    $initial_order->commerce_customer_billing = (array) $this->createDummyCustomerProfile('billing', $this->customer->uid);
    $initial_order->status = 'completed';
    commerce_order_save($initial_order);

    // Run cron.
    drupal_cron_run();
    $recurring_entities = entity_load('commerce_recurring', array($recurring_entity->id), array(), TRUE);
    $recurring_entity = reset($recurring_entities);
    $recurring_wrapper = entity_metadata_wrapper('commerce_recurring', $recurring_entity);
    $count_values = count($recurring_wrapper->commerce_recurring_order->raw());
    $this->assertEqual($count_values, 1, t('Second order was not generated at cron as the end date is in the past.'));
    $this->assertEqual($recurring_entity->status, 0, t('Recurring entity has been disabled.'));
  }

  /**
   * Test adding a regular product so it shouldn't recur.
   */
  function testCommmerceRecurringRegularProduct() {
    $this->drupalLogin($this->customer);
    $order = $this->createDummyOrder($this->customer->uid);
    $this->drupalPost($this->getCommerceUrl('cart'), array(), t('Checkout'));

    // Generate random information, as city, postal code, etc.
    $address_info = $this->generateAddressInformation();
    // Fill in the billing address information.
    $billing_pane = $this->xpath("//select[starts-with(@name, 'customer_profile_billing[commerce_customer_address]')]");
    $this->drupalPostAJAX(NULL, array((string) $billing_pane[0]['name'] => 'US'), (string) $billing_pane[0]['name']);
    // Fill in the required information for billing pane, with a random State.
    $info = array(
      'customer_profile_billing[commerce_customer_address][und][0][name_line]' => $address_info['name_line'],
      'customer_profile_billing[commerce_customer_address][und][0][thoroughfare]' => $address_info['thoroughfare'],
      'customer_profile_billing[commerce_customer_address][und][0][locality]' => $address_info['locality'],
      'customer_profile_billing[commerce_customer_address][und][0][administrative_area]' => 'KY',
      'customer_profile_billing[commerce_customer_address][und][0][postal_code]' => $address_info['postal_code'],
    );
    $this->drupalPost(NULL, $info, t('Continue to next step'));
    // Finish checkout process
    $this->drupalPost(NULL, array('commerce_payment[payment_method]' => 'commerce_payment_example|commerce_payment_commerce_payment_example'), t('Continue to next step'));

    $orders = commerce_order_load_multiple(array($order->order_id), array(), TRUE);
    $order = reset($orders);
    $this->assertEqual(array(), commerce_recurring_load_by_order($order), t('No recurring entities associated with the order.'));
  }

  /**
   * Test anonymous behaviour.
   */
  function testCommerceRecurringAnonymousOrder() {
    //module_enable(array('commerce_recurring_ui'));
    $recurring_product = $this->createRecurringProduct();
    $this->createDummyProductDisplayContentType('product_display', TRUE, 'field_product', FIELD_CARDINALITY_UNLIMITED);
    $node = $this->createDummyProductNode(array($recurring_product->product_id));

    user_role_change_permissions(DRUPAL_ANONYMOUS_RID, array(
      'access checkout' => TRUE,
    ));
    // Ensure we're not logged in.
    $this->drupalLogout();
    // Override user variable to get the enviroment fully set.
    global $user;
    $user = user_load(0);

    // Submit the add to cart form.
    $this->drupalPost('node/' . $node->nid, array(), t('Add to cart'));

    // Get the order for the anonymous user.
    $orders = commerce_order_load_multiple(array(), array('uid' => $user->uid, 'status' => 'cart'), TRUE);
    $order = reset($orders);
    // Reset the cache as we don't want to keep the lock.
    entity_get_controller('commerce_order')->resetCache();

    $this->drupalPost($this->getCommerceUrl('cart'), array(), t('Checkout'));

    // Generate random information, as city, postal code, etc.
    $address_info = $this->generateAddressInformation();
    // Fill in the billing address information.
    $billing_pane = $this->xpath("//select[starts-with(@name, 'customer_profile_billing[commerce_customer_address]')]");
    $this->drupalPostAJAX(NULL, array((string) $billing_pane[0]['name'] => 'US'), (string) $billing_pane[0]['name']);
    // Fill in the required information for billing pane, with a random State.
    $info = array(
      'account[login][mail]' => $this->customer->mail,
      'customer_profile_billing[commerce_customer_address][und][0][name_line]' => $address_info['name_line'],
      'customer_profile_billing[commerce_customer_address][und][0][thoroughfare]' => $address_info['thoroughfare'],
      'customer_profile_billing[commerce_customer_address][und][0][locality]' => $address_info['locality'],
      'customer_profile_billing[commerce_customer_address][und][0][administrative_area]' => 'KY',
      'customer_profile_billing[commerce_customer_address][und][0][postal_code]' => $address_info['postal_code'],
    );
    $this->drupalPost(NULL, $info, t('Continue to next step'));
    // Finish checkout process
    $this->drupalPost(NULL, array('commerce_payment[payment_method]' => 'commerce_payment_example|commerce_payment_commerce_payment_example'), t('Continue to next step'));
    // Load required entities.
    $order = commerce_order_load($order->order_id);
    entity_get_controller('commerce_order')->resetCache();

    $recurring_entities = commerce_recurring_load_by_order($order);
    $recurring_entity = reset($recurring_entities);
    $recurring_wrapper = entity_metadata_wrapper('commerce_recurring', $recurring_entity);
    $this->assertTrue(!empty($recurring_entities), 'A recurring entity was created for the order');
    $this->assertEqual(count($recurring_entities), 1, 'Only one recurring entity was created for the order');
    $this->assertEqual($recurring_wrapper->commerce_recurring_ref_product->value(), $recurring_product, 'Recurring product is associated with the recurring entity');
    $this->assertEqual($recurring_entity->uid, $this->customer->uid, 'Recurring entity is assigned to the registered user');
  }

  /**
   * Test purchasing a Regular product and a recurring product.
   */
  function testCommerceRecurringRegularAndRecurringProducts() {
    $this->drupalLogin($this->customer);
    $regular_product = $this->createDummyProduct();
    $line_item = commerce_cart_product_add_by_id($regular_product->product_id, 1, TRUE, $this->customer->uid);
    $recurring_product = $this->createRecurringProduct();
    $line_item = commerce_cart_product_add_by_id($recurring_product->product_id, 1, TRUE, $this->customer->uid);
    $this->drupalPost($this->getCommerceUrl('cart'), array(), t('Checkout'));

    // Generate random information, as city, postal code, etc.
    $address_info = $this->generateAddressInformation();
    // Fill in the billing address information.
    $billing_pane = $this->xpath("//select[starts-with(@name, 'customer_profile_billing[commerce_customer_address]')]");
    $this->drupalPostAJAX(NULL, array((string) $billing_pane[0]['name'] => 'US'), (string) $billing_pane[0]['name']);
    // Fill in the required information for billing pane, with a random State.
    $info = array(
      'customer_profile_billing[commerce_customer_address][und][0][name_line]' => $address_info['name_line'],
      'customer_profile_billing[commerce_customer_address][und][0][thoroughfare]' => $address_info['thoroughfare'],
      'customer_profile_billing[commerce_customer_address][und][0][locality]' => $address_info['locality'],
      'customer_profile_billing[commerce_customer_address][und][0][administrative_area]' => 'KY',
      'customer_profile_billing[commerce_customer_address][und][0][postal_code]' => $address_info['postal_code'],
    );
    $this->drupalPost(NULL, $info, t('Continue to next step'));
    // Finish checkout process
    $this->drupalPost(NULL, array('commerce_payment[payment_method]' => 'commerce_payment_example|commerce_payment_commerce_payment_example'), t('Continue to next step'));
    // Load required entities.
    $order = commerce_order_load($line_item->order_id);
    $recurring_entities = commerce_recurring_load_by_order($order);
    $recurring_entity = reset($recurring_entities);
    $recurring_wrapper = entity_metadata_wrapper('commerce_recurring', $recurring_entity);
    $this->assertTrue(!empty($recurring_entities), t('A recurring entity was created for the order'));
    $this->assertEqual(count($recurring_entities), 1, t('Only one recurring entity was created for the order'));
    $this->assertEqual($recurring_wrapper->commerce_recurring_ref_product->value(), $recurring_product, t('Recurring product is associated with the recurring entity'));
    $this->assertNotEqual($recurring_wrapper->commerce_recurring_ref_product->value(), $regular_product, t('Regular product is not associated with the recurring entity'));
  }

  /**
   * Test purchasing a several recurring products.
   */
  function testCommerceRecurringPurchaseTwoRecurringProducts() {
    $this->drupalLogin($this->customer);
    $first_recurring_product = $this->createRecurringProduct();
    $line_item = commerce_cart_product_add_by_id($first_recurring_product->product_id, 1, TRUE, $this->customer->uid);
    $second_recurring_product = $this->createRecurringProduct();
    $line_item = commerce_cart_product_add_by_id($second_recurring_product->product_id, 1, TRUE, $this->customer->uid);
    $this->drupalPost($this->getCommerceUrl('cart'), array(), t('Checkout'));

    // Generate random information, as city, postal code, etc.
    $address_info = $this->generateAddressInformation();
    // Fill in the billing address information.
    $billing_pane = $this->xpath("//select[starts-with(@name, 'customer_profile_billing[commerce_customer_address]')]");
    $this->drupalPostAJAX(NULL, array((string) $billing_pane[0]['name'] => 'US'), (string) $billing_pane[0]['name']);
    // Fill in the required information for billing pane, with a random State.
    $info = array(
      'customer_profile_billing[commerce_customer_address][und][0][name_line]' => $address_info['name_line'],
      'customer_profile_billing[commerce_customer_address][und][0][thoroughfare]' => $address_info['thoroughfare'],
      'customer_profile_billing[commerce_customer_address][und][0][locality]' => $address_info['locality'],
      'customer_profile_billing[commerce_customer_address][und][0][administrative_area]' => 'KY',
      'customer_profile_billing[commerce_customer_address][und][0][postal_code]' => $address_info['postal_code'],
    );
    $this->drupalPost(NULL, $info, t('Continue to next step'));
    // Finish checkout process
    $this->drupalPost(NULL, array('commerce_payment[payment_method]' => 'commerce_payment_example|commerce_payment_commerce_payment_example'), t('Continue to next step'));
    $order = commerce_order_load($line_item->order_id);
    $this->assertEqual(count(commerce_recurring_load_by_order($order)), 2, t('Two recurring entities are created when there are two recurring products in the cart.'));
  }

  /**
   * Test recurring entity creation with quantity.
   */
  function testCommerceRecurringCreatingRecurringEntityQuantity() {
    $this->drupalLogin($this->customer);
    $product = $this->createRecurringProduct();
    $line_item = commerce_cart_product_add_by_id($product->product_id, 2, TRUE, $this->customer->uid);
    $this->drupalPost($this->getCommerceUrl('cart'), array(), t('Checkout'));
    // Generate random information, as city, postal code, etc.
    $address_info = $this->generateAddressInformation();
    // Fill in the billing address information.
    $billing_pane = $this->xpath("//select[starts-with(@name, 'customer_profile_billing[commerce_customer_address]')]");
    $this->drupalPostAJAX(NULL, array((string) $billing_pane[0]['name'] => 'US'), (string) $billing_pane[0]['name']);
    // Fill in the required information for billing pane, with a random State.
    $info = array(
      'customer_profile_billing[commerce_customer_address][und][0][name_line]' => $address_info['name_line'],
      'customer_profile_billing[commerce_customer_address][und][0][thoroughfare]' => $address_info['thoroughfare'],
      'customer_profile_billing[commerce_customer_address][und][0][locality]' => $address_info['locality'],
      'customer_profile_billing[commerce_customer_address][und][0][administrative_area]' => 'KY',
      'customer_profile_billing[commerce_customer_address][und][0][postal_code]' => $address_info['postal_code'],
    );
    $this->drupalPost(NULL, $info, t('Continue to next step'));
    // Finish checkout process
    $this->drupalPost(NULL, array('commerce_payment[payment_method]' => 'commerce_payment_example|commerce_payment_commerce_payment_example'), t('Continue to next step'));
    $order = commerce_order_load($line_item->order_id);
    $recurring_entities = commerce_recurring_load_by_order($order);
    $recurring_entity = reset($recurring_entities);

    $this->assertEqual($recurring_entity->quantity, 2, t('The recurring entity generated has quantity 2.'));
    $this->assertEqual($recurring_entity->commerce_recurring_fixed_price[LANGUAGE_NONE][0]['amount'], $product->commerce_recurring_ini_price[LANGUAGE_NONE][0]['amount'], t('Recurring entity fixed price is the product initial price.'));
    $this->assertEqual(count(commerce_recurring_load_by_order($order)), 1, t('Just one recurring entity has been created.'));
  }

  /**
   * Test recurring orders with quantity.
   */
  function testCommerceRecurringCronOrderCreationWithQuantity() {
    // Create a recurring entity.
    $product = $this->createRecurringProduct();
    $line_item = commerce_cart_product_add_by_id($product->product_id, 2, TRUE, $this->customer->uid);
    $recurring_entity = $this->createRecurringEntity($product, 2);

    $initial_order = commerce_order_load($line_item->order_id);
    $initial_order->commerce_customer_billing = (array) $this->createDummyCustomerProfile('billing', $this->customer->uid);
    $initial_order->status = 'completed';
    commerce_order_save($initial_order);
    commerce_cart_order_ids_reset();

    // Run cron.
    drupal_cron_run();
    // Check if the order has been correctly created and it's linked to the
    // recurring entity.
    $recurring_entities = entity_load('commerce_recurring', array($recurring_entity->id), array(), TRUE);
    $recurring_entity = reset($recurring_entities);
    $recurring_wrapper = entity_metadata_wrapper('commerce_recurring', $recurring_entity);

    // The order is the second one now.
    $order_wrapper = $recurring_wrapper->commerce_recurring_order->get(1);
    $order = $order_wrapper->value();

    $this->assertTrue(isset($order), t('New order has been created for the recurring entity'));
    $this->assertEqual($order_wrapper->commerce_line_items->get(0)->quantity->value(), 2, t('Order line item with the recurring product has quantity 2.'));
  }

  /**
   * Test product is recurring check.
   */
  function testCommerceRecurringProductIsRecurring() {
    // Create a recurring and a non recurring product.
    $recurring_product = $this->createRecurringProduct();
    $regular_product = $this->createDummyProduct();

    $this->assertFalse(commerce_recurring_product_is_recurring($regular_product), t('Regular product not identified as recurring.'));
    $this->assertTrue(commerce_recurring_product_is_recurring($recurring_product), t('Recurring product identified as recurring.'));
  }

  /**
   * Test price list for recurring products.
   */
  function testCommerceRecurringProductPriceListing() {
    $this->drupalLogin($this->customer);
    $recurring_product = $this->createRecurringProduct();
    $this->createDummyProductDisplayContentType('product_display', TRUE, 'field_product', FIELD_CARDINALITY_UNLIMITED);
    $node = $this->createDummyProductNode(array($recurring_product->product_id));
    $expected_price = commerce_currency_format($recurring_product->commerce_recurring_ini_price[LANGUAGE_NONE][0]['amount'], $recurring_product->commerce_recurring_ini_price[LANGUAGE_NONE][0]['currency_code']);

    // Check if the price is right in the product display page.
    // Price should be the initial one.
    $this->drupalGet('node/' . $node->nid);

    // Add the cart block to the product page.
    $site_admin = $this->createSiteAdmin();
    $this->drupalLogin($site_admin);
    $this->drupalGet('admin/structure/block/manage');
    $edit = array();
    $edit['blocks[commerce_cart_cart][region]'] = 'sidebar_first';
    $this->drupalPost('admin/structure/block', $edit, t('Save blocks'));

    // Check if the price is right after adding the product to the cart.
    $this->drupalLogin($this->customer);
    $this->drupalPost('node/' . $node->nid, array(), t('Add to cart'));
    $this->assertText($expected_price, t('Recurring product price in the display page (with cart) is the initial one as expected.'));
  }

  /**
   * Test if the recurring entity is disabled when cancelling an order.
   */
  function testCommerceRecurringCancelRecurringFromOrder() {
    // Create a recurring entity.
    $product = $this->createRecurringProduct();
    $line_item = commerce_cart_product_add_by_id($product->product_id, 1, TRUE, $this->customer->uid);
    $start_date = new DateObject('2010-01-01');
    $due_date = new DateObject();
    $due_date->sub(new DateInterval('P1D'));
    $recurring_entity = $this->createRecurringEntity($product, 1, $start_date, $due_date);

    $order = commerce_order_load($line_item->order_id);
    $order->commerce_customer_billing = (array) $this->createDummyCustomerProfile('billing', $this->customer->uid);
    $order->status = 'completed';
    commerce_order_save($order);

    $order->status = 'canceled';
    commerce_order_save($order);
    $recurring_entity = entity_load_single('commerce_recurring', $recurring_entity->id);
    $this->assertEqual($recurring_entity->status, 0, t('Recurring entity has been disabled when the order is canceled'));
  }

}

/**
 * Test module enabling/disabling functionality.
 */
class CommerceRecurringEnableDisableTestCase extends ModuleTestCase {
  protected $module = 'commerce_recurring';
  protected $dependent_modules = array('commerce', 'commerce_cart', 'commerce_checkout', 'commerce_product', 'commerce_customer', 'commerce_line_item',
    'commerce_order', 'commerce_payment', 'commerce_price', 'commerce_product_reference', 'commerce_ui', 'commerce_product_ui', 'addressfield', 'entity',
    'rules', 'ctools', 'views', 'interval', 'entityreference', 'date', 'date_popup', 'date_api');

  public static function getInfo() {
    return array(
      'name' => 'Enable/disable commerce recurring',
      'description' => 'Enable/disable commerce recurring.',
      'group' => 'Commerce recurring',
    );
  }

  /**
   * setUp() performs any pre-requisite tasks that need to happen.
   *
   * Overrides the parent setup to be able to enable all the required modules.
   */
  public function setUp() {
    $modules = array_merge($this->dependent_modules, array($this->module));
    DrupalWebTestCase::setUp($modules);
    module_enable(array('system_test'));
    $this->admin_user = $this->drupalCreateUser(array(
      'access administration pages',
      'administer modules'
    ));
    $this->drupalLogin($this->admin_user);

  }

  /**
   * Assert if the recurring product type is present.
   *
   * @param $exist
   *   Boolean to check for the existance of the product type.
   * @return bool
   */
  function assertCommerRecurringProductType($exist) {
    commerce_product_types_reset();
    $product_types = commerce_product_types();
    return $this->assertEqual(isset($product_types['recurring']), $exist, t('Recurring product type does @not exist', array('@not' => ($exist == FALSE) ? t('not') : '')));
  }

  /**
   * Assert that the Recurring entity is present.
   *
   * @param $exist
   *   Boolean to check for the existance of the product type.
   * @return bool
   */
  function assertCommerceRecurringEntity($exist) {
    entity_info_cache_clear();
    $info = entity_get_info('commerce_recurring');
    return $this->assertEqual(!empty($info), $exist, t('Commerce recurring entity type does @not exist', array('@not' => ($exist == FALSE) ? t('not') : '')));
  }

  /**
   * Assert the list of fields exist or not.
   *
   * @param $fields
   *   Field list to check.
   * @param  entity_type
   *   Entity type.
   * @param  $bundle
   *   Bundle.
   * @param $exist
   *   Boolean to check for the existance of the field.
   */
  function assertCommerceRecurringFields(array $fields, $entity_type, $bundle, $exist) {
    field_info_cache_clear();
    $instances = field_info_instances($entity_type, $bundle);
    foreach ($fields as $field) {
      if ($exist) {
        $message = 'Field "@field" does exist.';
      }
      else {
        $message = 'Field "@field" does not exist.';
      }
      $info_field = field_info_field($field);
      $field_exist = (!empty($info_field) && !empty($instances[$field]));
      $this->assertEqual($field_exist, $exist, t($message, array('@field' => $field)));
    }
  }

  /**
   * Disable Commerce Recurring module.
   */
  public function disableCommerceRecurring() {
    $edit = array();
    $edit['modules[Commerce (contrib)][commerce_recurring][enable]'] = FALSE;
    $this->drupalPost('admin/modules', $edit, t('Save configuration'));
  }

  /**
   * Test if the module has been correctly enabled.
   */
  public function testCommerceRecurringEnable() {
    $modules = array_merge($this->dependent_modules, array($this->module));
    // Test enable.
    $this->assertModuleTablesExist($this->module);
    $this->assertModules($modules, TRUE);

    $this->assertCommerRecurringProductType(TRUE);
    $fields = array('commerce_recurring_ini_price', 'commerce_recurring_rec_price', 'commerce_recurring_ini_period', 'commerce_recurring_rec_period', 'commerce_recurring_end_period');
    $this->assertCommerceRecurringFields($fields, 'commerce_product', 'recurring', TRUE);

    $this->assertCommerceRecurringEntity(TRUE);
    $fields = array('commerce_recurring_ref_product', 'commerce_recurring_order', 'commerce_recurring_fixed_price');
    $this->assertCommerceRecurringFields($fields, 'commerce_recurring', 'product', TRUE);
  }

  /**
   * Test if the module can be correctly disabled.
   */
  public function testCommerceRecurringDisable() {
    // Test disable.
    $this->disableCommerceRecurring();
    $this->assertText(t('The configuration options have been saved.'), t('Modules status has been updated.'));
    $this->assertModules(array($this->module), FALSE);
    $this->assertModuleTablesExist($this->module);

    $this->assertCommerRecurringProductType(TRUE);
    $fields = array('commerce_recurring_ini_price', 'commerce_recurring_rec_price', 'commerce_recurring_ini_period', 'commerce_recurring_rec_period', 'commerce_recurring_end_period');
    $this->assertCommerceRecurringFields($fields, 'commerce_product', 'recurring', TRUE);

    $this->assertCommerceRecurringEntity(TRUE);
    $fields = array('commerce_recurring_ref_product', 'commerce_recurring_order', 'commerce_recurring_fixed_price');
    $this->assertCommerceRecurringFields($fields, 'commerce_recurring', 'product', TRUE);
  }

  /**
   * Test if the module can be correctly uninstalled.
   */
  public function testCommerceRecurringDisableUninstall() {
    $this->disableCommerceRecurring();
    // Uninstall the module.
    $edit = array();
    $edit['uninstall[' . $this->module . ']'] = $this->module;
    $this->drupalPost('admin/modules/uninstall', $edit, t('Uninstall'));
    $this->drupalPost(NULL, NULL, t('Uninstall'));
    $this->assertText(t('The selected modules have been uninstalled.'), t('Modules status has been updated.'));
    $this->assertModules(array($this->module), FALSE);
    $this->assertModuleTablesDoNotExist($this->module);

    $this->assertCommerRecurringProductType(FALSE);
    $fields = array('commerce_recurring_ini_price', 'commerce_recurring_rec_price', 'commerce_recurring_ini_period', 'commerce_recurring_rec_period', 'commerce_recurring_end_period');
    $this->assertCommerceRecurringFields($fields, 'commerce_product', 'recurring', FALSE);

    $fields = array('commerce_recurring_ref_product', 'commerce_recurring_order', 'commerce_recurring_fixed_price');
    $this->assertCommerceRecurringFields($fields, 'commerce_recurring', 'product', FALSE);
  }

}
